[["index.html", "brulR : Parler le même langage Préface", " brulR : Parler le même langage Caroline Brûlé 2024-10-02 Préface Bienvenue dans brulR: Parler le même langage, un guide conçu pour rendre notre travail quotidien avec R plus harmonieux, collaboratif et, surtout, plus compréhensible pour tous. Au fil du temps, nous avons tous développé nos propres habitudes de codage, mais ces différences peuvent parfois compliquer la collaboration et la révision de code au sein de notre équipe. C’est là que ce guide prend tout son sens. brulR n’est pas seulement un recueil de bonnes pratiques; c’est un effort collectif pour créer un langage commun, unifier nos syntaxes et ainsi simplifier nos échanges tout en améliorant la qualité de nos analyses. Que vous soyez un habitué de R ou que vous commenciez tout juste à explorer ses possibilités, ce guide est là pour vous accompagner. L’objectif est clair : uniformiser notre syntaxe pour que, en tant qu’équipe, nous parlions tous le même langage. Grâce à des exemples concrets et des conseils pratiques, brulR vous aidera à écrire du code propre, efficace et facilement compréhensible par tous. Ensemble, faisons en sorte que coder en R devienne une expérience encore plus fluide, cohérente et agréable. Merci de faire partie de cette aventure collective, où chacun de nous contribue à ce que nous parlions tous le même langage en R. "],["introduction.html", "Chapitre 1 Introduction 1.1 Pourquoi ce Manuel ? 1.2 Qu’est-ce que le Tidyverse ? 1.3 Les Packages du Tidyverse 1.4 Pas encore convaincu ? Quelles sont les alternatives ? 1.5 Conclusion", " Chapitre 1 Introduction 1.1 Pourquoi ce Manuel ? Dans un environnement où les projets d’analyse de données et de modélisation se multiplient, il devient crucial d’établir des pratiques de codage cohérentes. Ce manuel a été conçu pour vous proposer des lignes directrices qui visent à uniformiser la manière dont nous écrivons du code en R au sein de notre organisation. L’objectif est simple : faciliter la collaboration, améliorer la lisibilité du code et renforcer sa maintenabilité. Adopter des conventions communes en matière de syntaxe permet de réduire les erreurs, d’accélérer le processus de relecture par les pairs, et de rendre le code plus accessible, même pour ceux qui ne l’ont pas écrit. En d’autres termes, cela rend notre travail plus efficace et plus agréable. Pourquoi est-ce nécessaire ? Collaboration améliorée : Lorsque tout le monde suit des conventions similaires, il est plus facile de comprendre et de contribuer au code des autres. Réduction des erreurs : Des pratiques cohérentes réduisent les risques d’erreurs accidentelles et facilitent leur détection. Reproductibilité : Un code propre et bien documenté est plus facile à reproduire, ce qui est essentiel pour des projets scientifiques ou industriels. Formation et Intégration : Les nouveaux membres de l’équipe peuvent se familiariser plus rapidement avec le code existant si celui-ci suit des conventions claires et universelles. 1.2 Qu’est-ce que le Tidyverse ? Le tidyverse est un ensemble de packages en R qui partagent une philosophie commune de conception axée sur la lisibilité, la cohérence et l’efficacité. Ces packages sont conçus pour transformer les tâches de manipulation des données, de visualisation et d’analyse en processus simples et intuitifs, tout en étant puissants et flexibles. Les principes fondamentaux du tidyverse : Données tidy : Une structure où chaque variable est une colonne, chaque observation est une ligne, et chaque type d’observation forme une table distincte. Cette structure simplifie considérablement la manipulation des données. Syntaxe cohérente : Les fonctions des packages du tidyverse suivent une syntaxe uniforme, ce qui facilite l’apprentissage et l’utilisation de nouveaux outils. Interopérabilité : Les packages du tidyverse sont conçus pour fonctionner ensemble de manière fluide, ce qui permet de créer des flux de travail efficaces du début à la fin. Pourquoi adopter le tidyverse ? Lisibilité : Le code écrit en utilisant les packages du tidyverse est généralement plus lisible et plus facile à comprendre. Productivité : Les pipelines et les fonctions du tidyverse permettent d’écrire moins de code pour accomplir plus de choses, ce qui augmente la productivité. Écosystème riche : Le tidyverse s’intègre à un écosystème plus large de packages R, ce qui vous permet de réaliser des analyses complexes avec des outils familiers. 1.3 Les Packages du Tidyverse Voici une liste non exhaustive des principaux packages qui utilisent la syntaxe du tidyverse : ggplot2 : Pour créer des visualisations élégantes basées sur la grammaire des graphiques. dplyr : Pour la manipulation des données (filtrage, sélection, réordonnancement, regroupement, etc.). tidyr : Pour transformer les données, par exemple en passant d’un format large à un format long. readr : Pour lire des fichiers de données de manière rapide et cohérente. tibble : Pour travailler avec des data frames améliorés qui sont plus intuitifs et cohérents que les data frames de base. gt : Pour créer des tableaux élégants et personnalisables. purrr : Pour l’application de fonctions de manière élégante sur des listes et d’autres structures itérables. stringr : Pour la manipulation de chaînes de caractères avec des fonctions claires et cohérentes. forcats : Pour la gestion et la manipulation des variables de type facteur. Ces packages représentent le cœur du tidyverse, mais il en existe bien d’autres qui s’appuient sur la même syntaxe et philosophie, tels que lubridate pour la manipulation des dates, broom pour transformer les modèles statistiques en data frames, et janitor pour le nettoyage des données. 1.4 Pas encore convaincu ? Quelles sont les alternatives ? Si vous n’êtes pas encore convaincu que le tidyverse est l’approche la plus adaptée, il existe plusieurs alternatives populaires pour manipuler, analyser et visualiser des données en R. Cependant, chacune a ses propres avantages et inconvénients : 1.4.1 1. Base R Description : Les fonctions de base R permettent de manipuler les données sans avoir besoin de packages supplémentaires. Avantages : Pas de dépendances externes, très flexible pour des tâches spécifiques, performant pour certaines opérations. Inconvénients : Syntaxe moins intuitive, moins de cohérence, plus difficile à maintenir pour les projets complexes. 1.4.2 2. data.table Description : data.table est une extension rapide et efficace des data frames, idéale pour les grandes tables de données. Avantages : Très performant, syntaxe concise, utilisation efficace de la mémoire. Inconvénients : Syntaxe différente et parfois moins intuitive, courbe d’apprentissage plus élevée, intégration moins fluide avec d’autres packages R. 1.4.3 3. plyr Description : plyr est un package plus ancien pour la manipulation des données, qui a précédé dplyr. Avantages : Offre des fonctionnalités similaires à dplyr, support pour des objets complexes comme les listes et les arrays. Inconvénients : Moins performant que dplyr, syntaxe plus verbeuse, moins activement maintenu. 1.4.4 4. sqldf Description : sqldf permet d’utiliser des requêtes SQL pour manipuler des data frames en R. Avantages : Permet d’utiliser SQL directement dans R, pas besoin d’apprendre de nouvelles syntaxes si vous êtes familier avec SQL. Inconvénients : Performance variable, syntaxe moins intégrée avec R, moins flexible pour certaines tâches. 1.5 Conclusion En comparant ces alternatives, le tidyverse se distingue par sa cohérence syntaxique, sa lisibilité et son intégration fluide entre les différents packages. Bien que des outils comme data.table ou la base R puissent offrir des avantages spécifiques, le tidyverse est souvent préféré pour sa capacité à rendre le code plus intuitif, maintenable et accessible à tous les membres de l’équipe. Nous vous invitons donc à adopter progressivement les suggestions de ce manuel pour aligner vos pratiques sur celles qui ont fait leurs preuves au sein de la communauté R, et ainsi améliorer la qualité et l’efficacité de notre travail collectif. "],["uniformiser-la-syntaxe-r.html", "Chapitre 2 Uniformiser la Syntaxe R 2.1 Structure et Organisation du Code 2.2 Nommage des Objets 2.3 Style de Code 2.4 Gestion des Données 2.5 Documentation et Commentaires 2.6 Tests et Validation 2.7 Gestion des Packages 2.8 Gestion des Erreurs 2.9 Reproductibilité", " Chapitre 2 Uniformiser la Syntaxe R Dans ce chapitre, nous vous proposons des lignes directrices pour uniformiser la syntaxe R au sein de notre organisation. Ces propositions visent à renforcer la cohérence, à faciliter la lisibilité et à encourager la collaboration entre les membres de l’équipe. Nous vous invitons à les adopter progressivement, en gardant à l’esprit qu’elles sont conçues pour être cohérentes avec les principes du tidyverse. 2.1 Structure et Organisation du Code Nous vous proposons de structurer le code en suivant ces principes pour améliorer sa clarté et sa maintenabilité. Modularité Décomposez le code en fonctions réutilisables et bien nommées. calculate_mean &lt;- function(data, var) { data %&gt;% group_by(category) %&gt;% summarize(mean_value = mean({{ var }}, na.rm = TRUE)) } Sections Commentées Divisez le code en blocs logiques à l’aide de commentaires. # --- Importation des données --- data &lt;- read_csv(&quot;data.csv&quot;) # --- Nettoyage des données --- cleaned_data &lt;- data %&gt;% filter(!is.na(variable)) Fichiers Scripts Chaque script doit avoir une responsabilité principale, par exemple l’importation de données, le nettoyage, ou l’analyse. Si un script devient trop long, envisagez de le diviser en plusieurs scripts. 2.2 Nommage des Objets Un nommage clair et cohérent facilite la compréhension et la maintenance du code. Voici nos propositions : Variables et Fonctions Utilisez des noms descriptifs en anglais, avec la notation snake_case. mean_temperature &lt;- calculate_mean(data, temperature) Constantes Nommez les constantes en majuscules avec des underscores pour séparer les mots. MAX_ITERATIONS &lt;- 100 Variables Temporaires Réservez des noms comme tmp, i, ou j pour des variables temporaires dans des boucles ou des opérations rapides. 2.3 Style de Code Pour un code propre et lisible, nous vous proposons les règles suivantes : Indentation Utilisez deux espaces pour l'indentation. Évitez les tabulations. Espaces Ajoutez un espace après chaque virgule dans les arguments de fonctions et autour des opérateurs mathématiques et logiques. result &lt;- a + b data &lt;- data %&gt;% filter(var1 &gt; threshold) Longueur des Lignes Limitez la longueur des lignes de code à 80 caractères pour éviter le défilement horizontal. Accolades Ouvrez les accolades { sur la même ligne que la condition, et fermez-les sur une nouvelle ligne. if (x &gt; 0) { print(&quot;Positive&quot;) } 2.4 Gestion des Données Nous vous recommandons d’adopter le tidyverse pour la gestion des données, en raison de sa cohérence et de sa lisibilité. Tidyverse Favorisez l’utilisation des fonctions du tidyverse (dplyr, tidyr, etc.). summarized_data &lt;- data %&gt;% group_by(category) %&gt;% summarize(mean_value = mean(var2, na.rm = TRUE)) Pipelines (%&gt;%) Utilisez le pipe %&gt;% pour chaîner les opérations de manière claire. cleaned_data &lt;- raw_data %&gt;% filter(!is.na(variable)) %&gt;% mutate(variable = as.numeric(variable)) Noms des Colonnes Utilisez la notation snake_case pour les noms de colonnes, avec des noms significatifs. data &lt;- data %&gt;% rename(mean_temp = avg_temperature) 2.5 Documentation et Commentaires Pour rendre le code plus compréhensible, nous vous suggérons d’adopter ces pratiques en matière de documentation : Commentaires Expliquez les portions complexes du code avec des commentaires concis. # Calculer la moyenne de chaque groupe grouped_data &lt;- data %&gt;% group_by(category) %&gt;% summarize(mean_value = mean(var2, na.rm = TRUE)) Documentation des Fonctions Documentez chaque fonction en utilisant roxygen2 pour faciliter l’utilisation par d’autres. #&#39; Calculate the mean value of a variable #&#39; #&#39; @param data A data frame containing the data #&#39; @param var The name of the variable to summarize #&#39; @return A data frame with the mean value calculate_mean &lt;- function(data, var) { data %&gt;% group_by(category) %&gt;% summarize(mean_value = mean({{ var }}, na.rm = TRUE)) } 2.6 Tests et Validation Pour garantir la fiabilité du code, nous vous proposons d’intégrer des tests et des validations : Tests Unitaires Pour les fonctions complexes ou critiques, écrivez des tests unitaires avec testthat. test_that(&quot;calculate_mean works correctly&quot;, { result &lt;- calculate_mean(data, var) expect_equal(result$mean_value, expected_value) }) Validation des Données Avant d’effectuer des analyses, validez la structure et la qualité des données. stopifnot(all(!is.na(data$variable))) 2.7 Gestion des Packages Pour une gestion efficace des packages, nous vous suggérons les pratiques suivantes : Chargement des Packages Chargez les packages nécessaires au début du script. library(dplyr) library(ggplot2) Version des Packages Documentez les versions critiques des packages ou utilisez renv pour assurer la reproductibilité. renv::snapshot() 2.8 Gestion des Erreurs Nous vous recommandons d’adopter une gestion proactive des erreurs pour améliorer la robustesse du code : Gestion des Exceptions Utilisez tryCatch pour capturer et gérer les erreurs dans les processus critiques. result &lt;- tryCatch({ risky_operation() }, error = function(e) { message(&quot;An error occurred: &quot;, e$message) NULL }) 2.9 Reproductibilité Pour assurer la reproductibilité des analyses, nous vous proposons de suivre ces pratiques : Set Seed Utilisez set.seed() pour assurer la reproductibilité des résultats aléatoires. set.seed(123) Scripts Paramétrables Lorsque possible, écrivez des scripts paramétrables pour permettre leur réutilisation. params &lt;- list(input_file = &quot;data.csv&quot;, output_file = &quot;results.csv&quot;) process_data &lt;- function(params) { data &lt;- read_csv(params$input_file) # Traitement des données write_csv(data, params$output_file) } process_data(params) Ces propositions sont ouvertes à la discussion et à l’adaptation en fonction des besoins spécifiques de nos projets. En adoptant ces pratiques, nous visons à rendre notre code plus lisible, maintenable et compatible avec les standards de la communauté R, tout en restant fidèle à la philosophie du tidyverse. "],["importation-des-données.html", "Chapitre 3 Importation des données 3.1 Gérer les chemins de fichiers de manière robuste avec file.path() 3.2 Télécharger des feuilles spécifiques d’un fichier XLSX", " Chapitre 3 Importation des données 3.1 Gérer les chemins de fichiers de manière robuste avec file.path() Lorsqu’on travaille avec des fichiers sur différents systèmes d’exploitation ou dans des environnements partagés (comme un gros serveur), il est essentiel de gérer les chemins de fichiers de manière à éviter les erreurs dues à des séparateurs de dossiers incorrects ou à des chemins absolus spécifiques à un système. 3.1.1 Pourquoi utiliser file.path() ? La fonction file.path() est particulièrement utile pour construire des chemins de fichiers de manière sûre et portable. Voici quelques raisons pour lesquelles vous devriez utiliser file.path() : Séparateurs automatiques : file.path() insère automatiquement les bons séparateurs de dossiers (/ pour Linux et macOS, \\ pour Windows), évitant ainsi les erreurs. Portabilité : Votre code fonctionnera de manière identique quel que soit le système d’exploitation utilisé. Clarté : Le code devient plus lisible, en séparant clairement les différents composants du chemin de fichier. 3.1.2 Exemple avec un fichier CSV Supposons que vous avez un fichier CSV appelé mon_fichier.csv situé dans un dossier data, lui-même dans un dossier parent projet. Voici comment vous pouvez construire le chemin de ce fichier et le lire dans R : # Charger les packages nécessaires library(readr) # Construire le chemin complet du fichier CSV chemin_csv &lt;- file.path(&quot;projet&quot;, &quot;data&quot;, &quot;mon_fichier.csv&quot;) #on évite &quot;chemin/vers/votre_fichier.csv&quot; # Lire le fichier CSV dans un dataframe mon_dataframe &lt;- read_csv(chemin_csv) # Lire le fichier CSV dans un dataframe mon_dataframe &lt;- read_csv(chemin_local) Dans cet exemple, file.path(\"projet\", \"data\", \"mon_fichier.csv\") crée un chemin correct en fonction du système d’exploitation, que ce soit sur votre machine locale ou sur un serveur. 3.1.3 Exemple avec un fichier XLSX Le même principe s’applique si vous travaillez avec des fichiers Excel (.xlsx). Par exemple, si vous avez un fichier mon_tableau.xlsx dans le même dossier data, vous pouvez le lire ainsi : # Charger le package readxl pour lire les fichiers XLSX library(readxl) # Construire le chemin complet du fichier XLSX chemin_xlsx &lt;- file.path(&quot;projet&quot;, &quot;data&quot;, &quot;mon_tableau.xlsx&quot;) # Lire la première feuille du fichier XLSX dans un dataframe mon_tableau &lt;- read_excel(chemin_xlsx) Ici, file.path(\"projet\", \"data\", \"mon_tableau.xlsx\") s’assure que le chemin du fichier est correctement formaté, évitant ainsi les erreurs dues à des séparateurs de dossiers incorrects. 3.1.4 Conclusion En utilisant file.path(), vous vous assurez que les chemins de fichiers dans votre code R sont toujours construits de manière robuste, quelle que soit la plateforme sur laquelle vous travaillez. C’est une pratique simple mais essentielle pour écrire du code portable et fiable. 3.2 Télécharger des feuilles spécifiques d’un fichier XLSX Dans certains cas, vous pouvez avoir besoin de lire seulement une ou plusieurs feuilles spécifiques d’un fichier Excel (.xlsx). Le package readxl en R vous permet de le faire de manière simple et efficace. 3.2.1 Pourquoi lire des feuilles spécifiques ? Les fichiers Excel peuvent contenir plusieurs feuilles, chacune pouvant représenter un ensemble de données distinct. Il est souvent inutile de charger l’ensemble du fichier si vous avez besoin d’une seule feuille. Lire uniquement les feuilles spécifiques réduit l’utilisation de la mémoire et accélère le processus de chargement des données. 3.2.2 Charger une feuille spécifique Supposons que vous avez un fichier Excel appelé mon_fichier.xlsx avec plusieurs feuilles, et que vous souhaitez charger uniquement la feuille intitulée \"Feuille1\". # Charger le package readxl library(readxl) # Construire le chemin du fichier XLSX chemin_xlsx &lt;- file.path(&quot;projet&quot;, &quot;data&quot;, &quot;mon_fichier.xlsx&quot;) # Lire la feuille spécifique &quot;Feuille1&quot; dans un dataframe feuille1_dataframe &lt;- read_excel(chemin_xlsx, sheet = &quot;Feuille1&quot;) Dans cet exemple, read_excel() avec l’argument sheet spécifie la feuille à lire. Le chemin complet du fichier est construit à l’aide de file.path() pour assurer la portabilité du code. 3.2.3 Lire plusieurs feuilles Si vous avez besoin de lire plusieurs feuilles, vous pouvez procéder de la manière suivante : # Lire plusieurs feuilles spécifiques en une seule fois feuilles &lt;- c(&quot;Feuille1&quot;, &quot;Feuille2&quot;) # Utiliser lapply pour lire chaque feuille dans une liste de dataframes liste_dataframes &lt;- lapply(feuilles, function(feuille) { read_excel(chemin_xlsx, sheet = feuille) }) # Afficher les premières lignes de chaque dataframe lapply(liste_dataframes, head) Dans cet exemple, lapply() est utilisé pour lire plusieurs feuilles spécifiques et les stocker dans une liste de dataframes. Cela permet de travailler facilement avec plusieurs ensembles de données provenant du même fichier Excel. 3.2.4 Lire une feuille par son numéro Vous pouvez aussi spécifier une feuille par son numéro d’ordre, ce qui est utile si vous ne connaissez pas le nom exact de la feuille : # Lire la première feuille du fichier premiere_feuille &lt;- read_excel(chemin_xlsx, sheet = 1) Dans ce cas, l’argument sheet = 1 indique que la première feuille du fichier doit être lue. 3.2.5 Conclusion La capacité de lire des feuilles spécifiques d’un fichier Excel vous donne une grande flexibilité dans la gestion de vos données. Que vous ayez besoin de travailler avec une seule feuille ou plusieurs, le package readxl et R vous fournissent les outils nécessaires pour le faire efficacement. "],["lart-du-reprex-pourquoi-et-comment-créer-des-exemples-reproductibles.html", "Chapitre 4 L’art du REPREX : pourquoi et comment créer des exemples reproductibles 4.1 Qu’est-ce qu’un REPREX ? 4.2 Pourquoi écrire un REPREX ? 4.3 Comment écrire un REPREX ? 4.4 Exemples de bonnes pratiques 4.5 Conclusion", " Chapitre 4 L’art du REPREX : pourquoi et comment créer des exemples reproductibles 4.1 Qu’est-ce qu’un REPREX ? Un REPREX, ou REPRoducible EXample, est un extrait de code qui reproduit un problème ou une question de manière concise et reproductible. Il s’agit d’une pratique essentielle lorsque vous demandez de l’aide, que vous partagez un problème sur un forum, ou que vous collaborez avec d’autres personnes sur un projet R. L’idée est de fournir un exemple minimal qui montre clairement le problème ou la question, tout en étant simple à comprendre et à exécuter. 4.2 Pourquoi écrire un REPREX ? Écrire un REPREX présente plusieurs avantages significatifs : Clarté : Un REPREX force à isoler le problème ou la question spécifique, éliminant le bruit des autres parties du code. Cela aide non seulement à clarifier la question pour les autres, mais aussi à mieux comprendre le problème vous-même. Reproductibilité : En fournissant un exemple reproductible, vous permettez à ceux qui vous aident de reproduire exactement le même problème que vous rencontrez. Cela accélère la résolution des problèmes. Efficacité : Un REPREX bien conçu permet à la personne qui vous aide de se concentrer sur l’essentiel, ce qui augmente les chances d’obtenir une réponse rapide et précise. Documentation : Les REPREX peuvent également servir de documentation pour des problèmes ou des questions résolus. Ils constituent des exemples concrets de ce qui a été essayé et de ce qui fonctionne ou ne fonctionne pas. Réflexion : Le processus d’écriture d’un REPREX peut souvent vous amener à trouver la solution par vous-même, en simplifiant et en isolant le problème. 4.3 Comment écrire un REPREX ? Voici les étapes pour écrire un bon REPREX : 4.3.1 Isoler le problème Commencez par isoler le problème ou la question spécifique que vous rencontrez. Essayez de réduire le code à l’essentiel nécessaire pour reproduire le problème. Évitez d’inclure des parties de code non pertinentes. 4.3.2 Utiliser des données simulées ou publiques Si possible, utilisez des données simulées ou un sous-ensemble de données publiques pour rendre votre exemple reproductible par tous. Vous pouvez utiliser des fonctions comme set.seed() pour garantir que les résultats sont reproductibles. set.seed(123) data &lt;- data.frame( x = rnorm(10), y = rnorm(10) ) 4.3.3 Inclure le contexte nécessaire Assurez-vous que votre REPREX inclut toutes les informations nécessaires pour reproduire le problème, telles que les packages utilisés, les options de configuration, et les versions importantes de R ou de packages. # Packages nécessaires library(ggplot2) # Exemple minimal set.seed(123) data &lt;- data.frame( x = rnorm(10), y = rnorm(10) ) # Problème : la fonction geom_point ne fonctionne pas comme prévu ggplot(data, aes(x, y)) + geom_point() + labs(title = &quot;Graphique d&#39;exemple&quot;) 4.3.4 Tester le REPREX Avant de partager votre REPREX, testez-le dans une nouvelle session R pour vous assurer qu’il reproduit bien le problème de manière isolée. Si le problème ne se reproduit pas, essayez de réduire encore le code ou de vérifier les dépendances. 4.3.5 Utiliser le package reprex Le package reprex (Reproducible Example) de R est conçu pour faciliter la création et le partage de REPREX. Il capture le code R, l’exécute, et produit une sortie formatée pour les forums, les e-mails, ou d’autres contextes. Pour créer un REPREX avec le package reprex : Installez et chargez le package : install.packages(&quot;reprex&quot;) library(reprex) Créez votre REPREX : reprex({ # Code ici set.seed(123) data &lt;- data.frame( x = rnorm(10), y = rnorm(10) ) ggplot(data, aes(x, y)) + geom_point() + labs(title = &quot;Graphique d&#39;exemple&quot;) }) reprex génère un extrait de code avec la sortie incluse, formaté pour être facilement partagé. 4.3.6 Partager le REPREX Une fois que votre REPREX est prêt et testé, partagez-le dans le contexte approprié, que ce soit un forum, un e-mail, ou un système de gestion de tickets. Assurez-vous que le formatage est correct et que tous les éléments nécessaires sont inclus. 4.4 Exemples de bonnes pratiques Bon REPREX : library(dplyr) data &lt;- data.frame(x = c(1, 2, NA, 4), y = c(5, 6, 7, NA)) result &lt;- data %&gt;% mutate(z = x + y) print(result) Mauvais REPREX : data &lt;- read.csv(&quot;myfile.csv&quot;) result &lt;- mutate(z = x + y) Dans le mauvais exemple, il manque les packages nécessaires, la source des données, et le problème n’est pas clairement défini. Le bon REPREX, en revanche, est autonome, clair, et reproduit un problème spécifique. 4.5 Conclusion L’écriture de REPREX est une compétence essentielle pour tout utilisateur de R, que ce soit pour demander de l’aide, collaborer avec des collègues, ou documenter des problèmes. Un REPREX bien conçu rend la communication plus efficace, permet de résoudre les problèmes plus rapidement, et contribue à un code plus clair et mieux documenté. Nous vous encourageons à intégrer la pratique des REPREX dans votre flux de travail quotidien, pour améliorer la qualité de vos interactions et de vos projets en R. Exemple complet d’un REPREX (utile en plus!) # Script pour la création de dossiers par lac # Auteur : Caroline Brule # Date : 4 mars 2024 # Objectif : Ce script crée un dossier pour chaque lac dans un répertoire spécifique, # afin de faciliter le regroupement et l&#39;organisation des analyses de données par lac. # Note importante : Ne pas exécuter ce script plusieurs fois afin d&#39;éviter d&#39;écraser # les dossiers existants et d&#39;en supprimer le contenu. # Chargement des bibliothèques nécessaires library(dplyr) library(fs) # Pour une gestion des fichiers plus robuste # 1. Préparer les données des lacs ---- # Création d&#39;un dataframe contenant les informations de base pour chaque lac lacs &lt;- tibble::tibble( no_lce = c(&quot;00001&quot;, &quot;00002&quot;, &quot;00003&quot;), nom_du_lac = c(&quot;Lac A&quot;, &quot;Lac B&quot;, &quot;Lac C&quot;), no_rsvl = c(&quot;0001&quot;, &quot;0002&quot;, &quot;0003&quot;) ) # 2. Générer les noms de dossiers ---- # Combiner les informations pour créer un nom unique pour chaque dossier lacs &lt;- lacs %&gt;% mutate( name_dossier = paste0(no_lce, &quot;_&quot;, nom_du_lac, &quot;_RSVL_&quot;, no_rsvl) ) # 3. Définir le répertoire cible ---- # Utilisation de file.path pour créer un chemin de fichier de manière robuste repertoire &lt;- file.path( &quot;X:&quot;, &quot;DOCUM&quot;, &quot;4500_Produits_val_ajoutee&quot;, &quot;Eau_Suivi&quot;, &quot;Lacs&quot;, &quot;Périphyton&quot;, &quot;Analyses de données&quot; ) # 4. Créer les dossiers ---- # Créer chaque dossier en utilisant fs::dir_create pour une gestion sécurisée lacs %&gt;% pull(name_dossier) %&gt;% walk(~ fs::dir_create(path = file.path(repertoire, .x))) # 5. Vérification finale ---- # Afficher la structure du dataframe pour vérifier les données traitées str(lacs) "],["cartes-interactives.html", "Chapitre 5 Cartes interactives 5.1 Configuration de base 5.2 Ajout de données géographiques 5.3 Personnalisation des cartes 5.4 Interaction utilisateur 5.5 Gestion de grandes quantités de données", " Chapitre 5 Cartes interactives 5.1 Configuration de base Syntaxe de base pour créer une carte : install.packages(&quot;leaflet&quot;) library(leaflet) leaflet() %&gt;% addTiles() %&gt;% setView(lng = -73.5673, lat = 45.5017, zoom = 10) 5.2 Ajout de données géographiques data &lt;- data.frame(lng = c(-73.5673, -73.568, -73.569), lat = c(45.5017, 45.502, 45.503), label = c(&quot;Point 1&quot;, &quot;Point 2&quot;, &quot;Point 3&quot;)) leaflet(data) %&gt;% addTiles() %&gt;% addMarkers(~lng, ~lat, popup = ~label) 5.3 Personnalisation des cartes Personnalisation des styles de marqueurs, de polygones, de lignes. Utilisation des options comme addLegend() pour ajouter des légendes aux cartes. Personnalisation de tuiles avec addProviderTiles() (e.g., OpenStreetMap, CartoDB, etc.). # Créer une carte Leaflet avec des tuiles OpenStreetMap (par défaut) leaflet() %&gt;% addProviderTiles(providers$OpenStreetMap) %&gt;% setView(lng = -73.5673, lat = 45.5017, zoom = 10) # Créer une carte Leaflet avec des tuiles CartoDB.Positron leaflet() %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% setView(lng = -73.5673, lat = 45.5017, zoom = 10) providers\\(OpenStreetMap : Utilise les tuiles par défaut d&#39;OpenStreetMap. providers\\)CartoDB.Positron : Utilise un style de carte plus clair, minimaliste, souvent utilisé pour des visualisations de données. Vous pouvez consulter la liste complète des styles de tuiles disponibles avec {leaflet} en visitant le site : https://leaflet-extras.github.io/leaflet-providers/preview/. Cela vous permettra de choisir la tuile qui convient le mieux à votre projet. 5.4 Interaction utilisateur Explication sur les interactions telles que les popups, les survols, et la capture d’événements comme les clics sur des marqueurs. leaflet() %&gt;% addTiles() %&gt;% addMarkers(lng = -73.5673, lat = 45.5017, popup = &quot;Centre-ville de Montréal&quot;) 5.5 Gestion de grandes quantités de données Conseils sur l’utilisation de Leaflet pour visualiser de grandes quantités de points (e.g., clustering). # Exemples de données avec coordonnées longitude/latitude data &lt;- data.frame( lng = c(-73.5673, -73.568, -73.569, -73.570, -73.571), lat = c(45.5017, 45.502, 45.503, 45.504, 45.505), label = c(&quot;Point 1&quot;, &quot;Point 2&quot;, &quot;Point 3&quot;, &quot;Point 4&quot;, &quot;Point 5&quot;) ) # Création de la carte avec clustering des marqueurs leaflet(data) %&gt;% addTiles() %&gt;% addMarkers(~lng, ~lat, popup = ~label, clusterOptions = markerClusterOptions()) "],["formattage-des-données.html", "Chapitre 6 Formattage des données 6.1 Noms de colonnes 6.2 Utilisation de labelled pour ajouter des étiquettes aux variables 6.3 Gestion des données manquantes", " Chapitre 6 Formattage des données 6.1 Noms de colonnes Une étape essentielle lors du nettoyage des données consiste à uniformiser les noms de colonnes afin de rendre le jeu de données plus lisible, cohérent, et compatible avec la syntaxe tidyverse. Les bonnes pratiques de formattage des noms de colonnes sont les suivantes : Utiliser uniquement des caractères alphanumériques : Les accents, espaces, et symboles spéciaux doivent être supprimés ou remplacés. Remplacer les espaces par des underscores (_). Utiliser des noms en minuscules pour assurer une uniformité. Rendre les noms explicites et descriptifs, sans abréviations inutiles. 6.1.1 Exemple de formattage Prenons un exemple simplifié de jeu de données où les noms de colonnes ne respectent pas encore ces bonnes pratiques. # Jeu de données avant formattage BD &lt;- data.frame( `N° RSVL (Alpha)` = 1:5, `Nom du lac` = c(&quot;Lac Beauport&quot;, &quot;Lac Tourbillon&quot;, &quot;Lac Sergent&quot;, &quot;Lac Bleu&quot;, &quot;Lac Jaune&quot;), `LCE: Latitude` = c(47, 47, 46.9, 46.9, 46.1), `LCE: Longitude` = c(-71.3, -71.2, -71.7, -72, -73.6), `CHLO-A` = c(2.51, 2.81, 5.75, 3.45, 3.06), `P-T-TRA` = c(5.19, 8.87, 8.43, 8.09, 6.66), `Profondeur moyenne` = c(4.1, 1.7, NA, 18.2, 11.5) ) # Visualisation des noms de colonnes colnames(BD) ## [1] &quot;N..RSVL..Alpha.&quot; &quot;Nom.du.lac&quot; &quot;LCE..Latitude&quot; ## [4] &quot;LCE..Longitude&quot; &quot;CHLO.A&quot; &quot;P.T.TRA&quot; ## [7] &quot;Profondeur.moyenne&quot; 6.1.2 Transformation avec janitor::clean_names() Pour appliquer les bonnes pratiques de formattage, nous utilisons la fonction clean_names() du package janitor. Elle permet de reformater automatiquement les noms de colonnes selon la norme snake_case, qui est largement adoptée dans la syntaxe tidyverse. # Chargement de la bibliothèque janitor library(janitor) # Nettoyage des noms de colonnes BD_clean &lt;- BD %&gt;% clean_names() # Visualisation des nouveaux noms de colonnes colnames(BD_clean) ## [1] &quot;n_rsvl_alpha&quot; &quot;nom_du_lac&quot; &quot;lce_latitude&quot; ## [4] &quot;lce_longitude&quot; &quot;chlo_a&quot; &quot;p_t_tra&quot; ## [7] &quot;profondeur_moyenne&quot; 6.1.3 Résultat après formattage Le jeu de données transformé respecte désormais les bonnes pratiques. Voici la correspondance entre les anciens noms et les nouveaux : Ancien nom Nouveau nom N° RSVL (Alpha) n_rsvl_alpha Nom du lac nom_du_lac LCE: Latitude lce_latitude LCE: Longitude lce_longitude CHLO-A chlo_a P-T-TRA p_t_tra Profondeur moyenne profondeur_moyenne Accents et caractères spéciaux : Les accents (N°) ont été transformés (n). Espaces et symboles : Les espaces ont été remplacés par des underscores (_), et les symboles comme : ou - ont été retirés. Minuscules : Les lettres majuscules ont été converties en minuscules. Cette approche garantit des noms de colonnes cohérents et conformes à la syntaxe tidyverse, facilitant l’utilisation dans des pipelines de manipulation de données avec {dplyr}, {ggplot2}, etc. 6.2 Utilisation de labelled pour ajouter des étiquettes aux variables En plus de bien nommer les colonnes, il est souvent utile d’ajouter des étiquettes (ou labels) aux variables afin de fournir des descriptions plus détaillées des colonnes dans un jeu de données. Cela est particulièrement utile lors du partage de données avec d’autres analystes ou pour la documentation. Le package labelled permet d’ajouter des étiquettes aux colonnes de manière efficace. 6.2.1 Pourquoi utiliser des étiquettes de variables ? Clarté : Les noms de colonnes peuvent être courts et concis, tandis que les étiquettes fournissent des descriptions complètes et explicites des variables. Documentation : L’ajout d’étiquettes aide à documenter chaque colonne, facilitant la compréhension du jeu de données, surtout lorsqu’il est partagé. 6.2.2 Exemple d’utilisation avec labelled Imaginons que vous souhaitez ajouter des étiquettes descriptives à certaines colonnes de votre jeu de données : # Chargement du package labelled library(labelled) ## Warning: le package &#39;labelled&#39; a été compilé avec la version R 4.3.3 # Jeu de données exemple BD &lt;- data.frame( no_rsvl_alpha = 1:5, nom_du_lac = c(&quot;Lac Beauport&quot;, &quot;Lac Tourbillon&quot;, &quot;Lac Sergent&quot;, &quot;Lac Bleu&quot;, &quot;Lac Jaune&quot;), lce_latitude = c(47, 47, 46.9, 46.9, 46.1), lce_longitude = c(-71.3, -71.2, -71.7, -72, -73.6), chlo_a = c(2.51, 2.81, 5.75, 3.45, 3.06) ) # Ajout d&#39;étiquettes aux variables BD_labelled &lt;- BD %&gt;% set_variable_labels( no_rsvl_alpha = &quot;Numéro RSVL du lac&quot;, nom_du_lac = &quot;Nom du lac&quot;, lce_latitude = &quot;Latitude du lac selon le LCE&quot;, lce_longitude = &quot;Longitude du lac selon le LCE&quot;, chlo_a = &quot;Concentration de chlorophylle-A&quot; ) # Visualisation des étiquettes des variables var_label(BD_labelled) ## $no_rsvl_alpha ## [1] &quot;Numéro RSVL du lac&quot; ## ## $nom_du_lac ## [1] &quot;Nom du lac&quot; ## ## $lce_latitude ## [1] &quot;Latitude du lac selon le LCE&quot; ## ## $lce_longitude ## [1] &quot;Longitude du lac selon le LCE&quot; ## ## $chlo_a ## [1] &quot;Concentration de chlorophylle-A&quot; 6.2.3 Explication set_variable_labels() : Cette fonction permet d’ajouter des descriptions aux colonnes du jeu de données. Les étiquettes ne changent pas le nom des colonnes mais fournissent des informations supplémentaires. Consultation des étiquettes : Pour vérifier ou afficher les étiquettes d’un jeu de données, vous pouvez utiliser la fonction var_label(). 6.2.4 Visualisation des étiquettes Vous pouvez également afficher les étiquettes dans un rapport ou un script de documentation. Par exemple, en utilisant la fonction var_label(), voici les étiquettes des variables : Colonne Étiquette n_rsvl_alpha Numéro RSVL du lac nom_du_lac Nom du lac lce_latitude Latitude du lac selon le LCE lce_longitude Longitude du lac selon le LCE chlo_a Concentration de chlorophylle-A 6.2.5 Intégration des étiquettes dans un workflow d’analyse L’ajout d’étiquettes est utile non seulement pour la documentation, mais aussi pour les analyses descriptives ou la production de rapports. Par exemple, ces étiquettes peuvent être utilisées lors de l’exportation des données ou lors de la génération de rapports avec des packages comme {gt}, {flextable}, ou {rmarkdown}. 6.3 Gestion des données manquantes Dans un jeu de données, il est courant de rencontrer des valeurs manquantes sous différentes formes : NA, NaN, des cases vides (\"\", \" \"), ou des espaces vides (\" \"). Le tidyverse propose plusieurs approches pour détecter, traiter et remplacer ces valeurs manquantes afin de garantir la qualité de vos analyses. 6.3.1 Détection des données manquantes Avant de traiter les valeurs manquantes, il est important de pouvoir les identifier. Voici quelques méthodes pour détecter les différentes formes de valeurs manquantes : library(dplyr) # Exemple de jeu de données avec différentes valeurs manquantes BD &lt;- data.frame( nom_du_lac = c(&quot;Lac Beauport&quot;, &quot;Lac Tourbillon&quot;, &quot;&quot;, &quot; &quot;, NA), profondeur_moyenne = c(4.1, NaN, NA, 18.2, 11.5), chlo_a = c(2.51, 2.81, NA, 3.45, &quot;&quot;) ) # Identifier les valeurs manquantes (NA, NaN, &quot;&quot;, &quot; &quot;) BD_clean &lt;- BD %&gt;% mutate(across(everything(), ~ ifelse(. %in% c(&quot;&quot;, &quot; &quot;, NA, NaN), NA, .))) # Visualiser le jeu de données après nettoyage BD_clean ## nom_du_lac profondeur_moyenne chlo_a ## 1 Lac Beauport 4.1 2.51 ## 2 Lac Tourbillon NA 2.81 ## 3 &lt;NA&gt; NA &lt;NA&gt; ## 4 &lt;NA&gt; 18.2 3.45 ## 5 &lt;NA&gt; 11.5 &lt;NA&gt; 6.3.2 Explication mutate(across()) : Utilise across() pour appliquer une transformation à toutes les colonnes. Cette approche permet de détecter et remplacer différentes formes de valeurs manquantes (NA, NaN, \"\", \" \"). ifelse() : Pour chaque colonne, nous remplaçons les valeurs \"\", \" \", NA, et NaN par NA, ce qui facilite la gestion homogène des valeurs manquantes dans le jeu de données. 6.3.3 Remplacer ou supprimer les valeurs manquantes Selon le contexte, vous pouvez choisir de : Remplacer les valeurs manquantes par une valeur spécifique (par exemple, 0 pour des variables numériques). Supprimer les lignes contenant des valeurs manquantes si ces données sont inutilisables. 6.3.3.1 Remplacer les valeurs manquantes # Charger la librairie tidyr library(tidyr) ## Warning: le package &#39;tidyr&#39; a été compilé avec la version R 4.3.2 # Remplacer les valeurs manquantes par 0 pour les colonnes numériques BD_clean &lt;- BD_clean %&gt;% mutate(across(where(is.numeric), ~ replace_na(., 0))) # Remplacer les valeurs manquantes par &quot;Inconnu&quot; pour les colonnes non numériques BD_clean &lt;- BD_clean %&gt;% mutate(across(where(is.character), ~ replace_na(., &quot;Inconnu&quot;))) # Visualiser le jeu de données après remplacement BD_clean ## nom_du_lac profondeur_moyenne chlo_a ## 1 Lac Beauport 4.1 2.51 ## 2 Lac Tourbillon 0.0 2.81 ## 3 Inconnu 0.0 Inconnu ## 4 Inconnu 18.2 3.45 ## 5 Inconnu 11.5 Inconnu 6.3.3.2 Supprimer les lignes avec des valeurs manquantes # Supprimer les lignes avec des valeurs manquantes dans n&#39;importe quelle colonne BD_clean &lt;- BD_clean %&gt;% drop_na() # Visualiser le jeu de données après suppression BD_clean ## nom_du_lac profondeur_moyenne chlo_a ## 1 Lac Beauport 4.1 2.51 ## 2 Lac Tourbillon 0.0 2.81 ## 3 Inconnu 0.0 Inconnu ## 4 Inconnu 18.2 3.45 ## 5 Inconnu 11.5 Inconnu 6.3.4 Stratégies de gestion des données manquantes Remplacement : Vous pouvez choisir de remplacer les valeurs manquantes par une valeur par défaut (comme 0 ou “Inconnu”). Cela peut être utile pour éviter la perte de données. Suppression : Lorsque les valeurs manquantes sont trop nombreuses ou lorsque ces données sont essentielles à l’analyse, il est parfois préférable de supprimer les lignes ou colonnes affectées. Imputation : Dans certains cas, vous pourriez envisager d’imputer les valeurs manquantes avec une méthode statistique, comme la moyenne ou la médiane. Ce processus n’est pas couvert dans cette section mais peut être exploré dans des contextes avancés. 6.3.5 Résumé Il est essentiel de détecter, nettoyer, et traiter les données manquantes de manière cohérente pour assurer la robustesse de vos analyses. Les fonctions du tidyverse telles que replace_na(), drop_na(), et mutate(across()) fournissent un moyen efficace de gérer les valeurs manquantes, quelles que soient leur forme. "],["structure-dun-projet-r-package-dépôt-et-projet.html", "Chapitre 7 Structure d’un projet R : Package, Dépôt, et Projet 7.1 Projets RStudio 7.2 Packages R 7.3 Dépôts (Repositories) 7.4 Différences entre package, dépôt, et projet 7.5 Bonnes pratiques pour structurer un projet", " Chapitre 7 Structure d’un projet R : Package, Dépôt, et Projet L’organisation d’un projet R est cruciale pour assurer la lisibilité, la maintenance, et la collaboration sur du code. Il existe plusieurs types de projets en R, chacun avec sa propre structure : package, dépôt (repo), et projet. Bien qu’ils partagent des points communs, ces structures répondent à des besoins différents. 7.1 Projets RStudio Les projets dans RStudio sont une manière d’organiser vos scripts, données et fichiers de travail. Un projet est un dossier où vous centralisez tous les fichiers associés à une analyse ou une tâche spécifique. Voici une structure typique : /MonProjet/ ├── data/ # Données brutes ou pré-traitées ├── R/ # Scripts R ├── output/ # Résultats, graphiques, rapports ├── reports/ # Fichiers RMarkdown ou Quarto pour rapports └── README.md # Description générale du projet Les projets facilitent : La reproductibilité : Un projet encapsule tout ce qui est nécessaire pour exécuter les analyses. L’isolation : Chaque projet a son propre espace de travail, ce qui évite les conflits de fichiers ou variables avec d’autres projets. 7.1.1 Points clés d’un projet R Fichier .Rproj : Ce fichier spécifique à RStudio contient les paramètres de projet. Organisation des dossiers : Séparez les scripts, données, et résultats pour garder une structure claire. Gestion des dépendances : Utilisez des outils comme {renv} pour gérer les versions de packages. 7.2 Packages R Un package R est un projet plus structuré destiné à être partagé et distribué. Il contient du code, de la documentation, et éventuellement des données, le tout dans une structure spécifique pour faciliter son installation et son utilisation. Voici la structure d’un package typique : /MonPackage/ ├── R/ # Fichiers R avec les fonctions ├── man/ # Documentation générée par roxygen2 ├── NAMESPACE # Déclaration des fonctions exportées ├── DESCRIPTION # Métadonnées sur le package ├── tests/ # Tests unitaires avec testthat ├── vignettes/ # Vignettes explicatives ├── data/ # Données incluses dans le package ├── inst/ # Fichiers divers (ex. : fichiers externes, exemples) └── README.md # Documentation du projet 7.2.1 Points clés d’un package R DESCRIPTION : Ce fichier contient les métadonnées du package (nom, auteur, dépendances, version). NAMESPACE : Liste les fonctions et objets exportés. Documentation : Utilisez {roxygen2} pour générer automatiquement la documentation dans le dossier man/. Les packages sont structurés pour être réutilisables et distribuables. Ils incluent des tests (tests/) pour garantir que le code fonctionne correctement dans différents contextes. 7.3 Dépôts (Repositories) Les dépôts (repos) sont souvent utilisés pour gérer le code via un contrôle de version (par exemple, avec Git et GitHub). Un dépôt est un espace de stockage pour un projet qui peut contenir du code, des packages, ou des analyses. Un dépôt peut être un projet ou un package, mais ce qui le distingue est l’utilisation du contrôle de version pour collaborer et suivre l’évolution du code. Voici une structure typique d’un dépôt Git : /MonRepo/ ├── .git/ # Dossier de métadonnées Git (suivi des versions) ├── R/ # Scripts ou fonctions R ├── data/ # Données brutes ou pré-traitées ├── output/ # Résultats ou graphiques ├── tests/ # Tests unitaires ├── README.md # Description du projet et instructions └── .gitignore # Fichiers à ignorer par Git 7.3.1 Points clés d'un dépôt .git/ : Géré par Git, ce dossier contient tout l'historique du projet. Collaboration : Le dépôt permet à plusieurs utilisateurs de travailler simultanément tout en gardant une trace des changements. GitHub : Permet de partager des dépôts en ligne, facilitant la collaboration. 7.4 Différences entre package, dépôt, et projet Aspect Projet RStudio Librairie R Dépôt (Repository) Usage Analyse de données Distribution de code Suivi du code Fichier clé .Rproj DESCRIPTION et NAMESPACE .git/ Documentation Fichiers RMarkdown ou Quarto Roxygen2 + Vignettes README.md, GitHub Pages Dépendances {renv}, DESCRIPTION {roxygen2}, testthat Git + GitHub Actions 7.5 Bonnes pratiques pour structurer un projet Isolation des scripts, données et sorties : Gardez vos scripts dans un dossier R/ ou scripts/, et les données dans un dossier data/. Séparez les résultats dans un dossier distinct comme output/. Documentation : Ajoutez un fichier README.md pour expliquer le but du projet, comment exécuter les analyses, et quelles dépendances sont nécessaires. Contrôle de version : Utilisez Git pour suivre l’évolution de votre code, même dans des projets RStudio ou des packages. "],["utilisation-de-ungroup-après-group_by.html", "Chapitre 8 Utilisation de ungroup() après group_by() 8.1 Pourquoi utiliser ungroup() ?", " Chapitre 8 Utilisation de ungroup() après group_by() Lors de la manipulation des données avec {dplyr}, il est courant d’utiliser group_by() pour regrouper les données par une ou plusieurs variables avant d’appliquer des fonctions d’agrégation ou de transformation. Cependant, il est important de dégrupper les données après avoir effectué ces opérations afin d’éviter des comportements inattendus dans les étapes suivantes du pipeline de traitement des données. 8.1 Pourquoi utiliser ungroup() ? Lorsque vous utilisez group_by(), votre jeu de données reste groupé après l’opération, ce qui peut influencer le comportement des fonctions suivantes dans le pipeline. Si vous ne retirez pas ces groupes explicitement, des erreurs ou des résultats inattendus peuvent survenir lorsque vous effectuez des opérations qui ne nécessitent pas de groupes. En appelant ungroup(), vous retirez l’attribut de regroupement des données, ce qui permet de continuer l’analyse sur un dataframe non-groupé. 8.1.1 Exemple d’utilisation de group_by() et ungroup() Voici un exemple classique montrant pourquoi et comment utiliser ungroup() après avoir travaillé avec des données groupées. library(dplyr) # Exemple de jeu de données data &lt;- data.frame( groupe = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;), valeur = c(10, 20, 30, 40, 50, 60) ) # 1. Regrouper les données par &#39;groupe&#39; et calculer la somme des valeurs data_grouped &lt;- data %&gt;% group_by(groupe) %&gt;% summarise(total = sum(valeur)) # Les données sont toujours groupées après summarise() print(data_grouped) ## # A tibble: 3 × 2 ## groupe total ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 30 ## 2 B 70 ## 3 C 110 # 2. Utiliser ungroup() pour supprimer le regroupement data_ungrouped &lt;- data_grouped %&gt;% ungroup() # Maintenant, les données ne sont plus groupées print(data_ungrouped) ## # A tibble: 3 × 2 ## groupe total ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 30 ## 2 B 70 ## 3 C 110 8.1.2 Explication group_by() : Cette fonction regroupe les lignes du dataframe par la variable groupe. Cela permet d’appliquer des calculs par groupe. summarise() : Cette fonction calcule la somme de la colonne valeur pour chaque groupe. Cependant, même après la summarisation, les données restent groupées. Pourquoi ungroup() ? : Si vous voulez appliquer d’autres transformations ou analyses sur le dataframe sans que les données soient toujours groupées, il est crucial d’appeler ungroup(). Cela empêche des comportements inattendus pour les fonctions suivantes. 8.1.3 Que se passe-t-il sans ungroup() ? Si vous n’utilisez pas ungroup(), certaines opérations postérieures au summarise() pourraient être affectées par la structure de regroupement. Par exemple, si vous tentez de modifier une colonne sans ungroup(), cela pourrait provoquer des erreurs ou des avertissements. Voici un exemple : # Sans ungroup(), certaines opérations peuvent ne pas fonctionner comme prévu data_grouped %&gt;% mutate(total_augmente = total + 10) # Fonctionne, mais le dataframe est encore groupé ## # A tibble: 3 × 3 ## groupe total total_augmente ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A 30 40 ## 2 B 70 80 ## 3 C 110 120 Dans certains cas, il peut aussi y avoir des performances moindres si des fonctions sont appliquées sur des données toujours groupées inutilement. 8.1.4 Bonnes pratiques Toujours dégroupper après un group_by() : Même si certaines opérations peuvent fonctionner avec des données encore groupées, il est préférable de toujours faire un ungroup() après avoir terminé les calculs sur des groupes. Cela garantit que les étapes suivantes du pipeline ne seront pas influencées par des groupes résiduels. Clarté et maintenance du code : Utiliser ungroup() explicite votre intention de revenir à un dataframe non-groupé, ce qui rend votre code plus clair pour d’autres utilisateurs (et vous-même dans le futur). 8.1.5 Cas pratique : Eviter les erreurs avec ungroup() Imaginons que vous souhaitiez calculer la moyenne après avoir agrégé les données par groupe. Si vous ne dégrouppez pas vos données après summarise(), vous risquez d’obtenir des erreurs dans le calcul de la moyenne sur l’ensemble du jeu de données. # Erreur potentielle sans ungroup() data_grouped %&gt;% mutate(moyenne = mean(total)) # La moyenne sera calculée par groupe et non globalement ## # A tibble: 3 × 3 ## groupe total moyenne ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A 30 70 ## 2 B 70 70 ## 3 C 110 70 # Solution avec ungroup() data_ungrouped &lt;- data_grouped %&gt;% ungroup() %&gt;% mutate(moyenne = mean(total)) # Calcul de la moyenne globale 8.1.6 Conclusion L’utilisation de ungroup() est une bonne pratique lorsque vous travaillez avec des fonctions comme group_by(). Cela permet de dégrupper explicitement les données après avoir effectué des agrégations ou des transformations, évitant ainsi des erreurs et assurant que les étapes suivantes de votre pipeline fonctionnent comme prévu. "],["boucles-lapply-et-map-quelles-méthodes-privilégier.html", "Chapitre 9 Boucles, lapply() et map() : quelles méthodes privilégier ? 9.1 Les boucles for 9.2 lapply() et les variantes de la famille apply() 9.3 map() et la famille purrr 9.4 Quelle méthode privilégier ? 9.5 Conclusion", " Chapitre 9 Boucles, lapply() et map() : quelles méthodes privilégier ? 9.1 Les boucles for Les boucles for sont une des méthodes les plus intuitives pour parcourir un ensemble de données en R. Elles permettent d’itérer explicitement sur des vecteurs, des listes ou des matrices. 9.1.1 Syntaxe d’une boucle for for (i in 1:10) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Dans cet exemple, la boucle itère de 1 à 10, imprimant chaque valeur. 9.1.2 Exemple pratique Supposons que vous ayez une liste de vecteurs et que vous souhaitiez calculer la somme de chaque vecteur. Vous pourriez utiliser une boucle for comme suit : # Liste de vecteurs liste_vecteurs &lt;- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)) # Calculer la somme de chaque vecteur avec une boucle for somme_vecteurs &lt;- numeric(length(liste_vecteurs)) for (i in 1:length(liste_vecteurs)) { somme_vecteurs[i] &lt;- sum(liste_vecteurs[[i]]) } print(somme_vecteurs) ## [1] 6 15 24 9.1.3 Avantages et inconvénients des boucles for Avantages : Clarté : La logique est facile à comprendre, même pour les débutants. Contrôle : Vous pouvez facilement ajouter des conditions, modifier des indices, ou déboguer le processus. Inconvénients : Performance : Les boucles for peuvent devenir plus lentes avec de grands volumes de données. Elles ne tirent pas parti des optimisations natives de R pour la manipulation de structures complexes comme les listes ou les dataframes. Lisibilité : Le code peut devenir plus verbeux, surtout pour des opérations répétitives. 9.2 lapply() et les variantes de la famille apply() La famille apply() propose des alternatives aux boucles pour appliquer des fonctions sur des structures comme des listes ou des matrices. Ces fonctions sont souvent plus performantes et concises. 9.2.1 lapply() lapply() est utilisée pour appliquer une fonction à chaque élément d’une liste et retourne une liste des résultats. # Appliquer sum() à chaque vecteur de la liste avec lapply somme_vecteurs &lt;- lapply(liste_vecteurs, sum) print(somme_vecteurs) ## [[1]] ## [1] 6 ## ## [[2]] ## [1] 15 ## ## [[3]] ## [1] 24 Avantages : Concision : Le code est plus court que celui des boucles for. Meilleure performance : Comparé à une boucle for, lapply() est souvent plus rapide car optimisé pour les listes. Inconvénients : Retourne toujours une liste : Si vous souhaitez un autre type de structure en sortie (e.g., vecteur ou dataframe), il faut convertir le résultat (e.g., unlist() pour obtenir un vecteur). 9.2.2 Autres variantes de apply() : sapply() : Similaire à lapply(), mais essaie de simplifier le résultat. Par exemple, il renvoie un vecteur au lieu d’une liste si possible : somme_vecteurs &lt;- sapply(liste_vecteurs, sum) print(somme_vecteurs) # retourne un vecteur ## [1] 6 15 24 tapply() : Applique une fonction à des sous-groupes définis par une variable de regroupement. Utile pour les agrégations par catégorie. apply() : Applique une fonction à des matrices ou dataframes, soit par ligne, soit par colonne 9.3 map() et la famille purrr La famille de fonctions map() appartient au package purrr (du tidyverse). Elle est similaire à lapply(), mais plus flexible et expressive. Elle permet de spécifier le type de sortie et fournit des fonctions pour manipuler les listes de manière plus puissante. 9.3.1 map() library(purrr) ## Warning: le package &#39;purrr&#39; a été compilé avec la version R 4.3.2 # Appliquer sum() à chaque vecteur de la liste avec map somme_vecteurs &lt;- map(liste_vecteurs, sum) print(somme_vecteurs) ## [[1]] ## [1] 6 ## ## [[2]] ## [1] 15 ## ## [[3]] ## [1] 24 Avantages : Flexibilité : Vous pouvez utiliser des variantes comme map_dbl() (pour retourner un vecteur numérique), map_chr() (pour retourner un vecteur de caractères), etc. Gestion d’erreurs intégrée : Avec purrr, vous pouvez facilement gérer les erreurs lors de l’application de fonctions avec des variantes comme safely() ou possibly(). Syntaxe fonctionnelle : L’approche de purrr est bien intégrée dans les workflows tidyverse, et encourage une écriture fonctionnelle. 9.3.2 Variantes de map() : map_dbl() : Retourne un vecteur numérique. somme_vecteurs &lt;- map_dbl(liste_vecteurs, sum) print(somme_vecteurs) # Retourne un vecteur numérique ## [1] 6 15 24 map2() : Applique une fonction sur deux listes simultanément, ce qui est utile pour comparer des éléments de deux listes de manière parallèle. pmap() : Applique une fonction à plusieurs listes ou dataframes, ce qui permet de travailler avec plusieurs ensembles de données en même temps. 9.4 Quelle méthode privilégier ? Utilisez for lorsque : Vous avez besoin de plus de contrôle sur l’itération (par exemple, ajouter des conditions complexes). Les itérations sont limitées et ne posent pas de problème de performance. Utilisez lapply()/sapply() lorsque : Vous travaillez avec des listes ou des vecteurs. Vous avez besoin de concision et d’optimisation pour des opérations simples et répétitives. Utilisez map() (de purrr) lorsque : Vous travaillez dans un pipeline tidyverse et souhaitez une approche plus fonctionnelle. Vous avez besoin d’une flexibilité accrue (par exemple, pour forcer le type de sortie ou gérer des erreurs). Vous manipulez des listes complexes ou souhaitez utiliser des outils comme map2() ou pmap() pour itérer sur plusieurs structures de données. 9.4.0.1 Exemple comparatif Voici un exemple qui compare les trois méthodes pour résoudre le même problème : calculer la somme de plusieurs vecteurs dans une liste. Avec for : somme_vecteurs &lt;- numeric(length(liste_vecteurs)) for (i in 1:length(liste_vecteurs)) { somme_vecteurs[i] &lt;- sum(liste_vecteurs[[i]]) } print(somme_vecteurs) ## [1] 6 15 24 Avec lapply() : somme_vecteurs &lt;- lapply(liste_vecteurs, sum) print(unlist(somme_vecteurs)) # Conversion en vecteur ## [1] 6 15 24 Avec map_dbl() de purrr : library(purrr) somme_vecteurs &lt;- map_dbl(liste_vecteurs, sum) print(somme_vecteurs) ## [1] 6 15 24 9.5 Conclusion Le choix de la méthode dépend de la complexité de l’opération, du volume des données, et de votre style de programmation préféré. Dans de nombreux cas, l’utilisation des fonctions de la famille apply() ou purrr::map() est plus performante et plus lisible que les boucles for. Toutefois, les boucles peuvent rester pertinentes pour des cas spécifiques nécessitant un contrôle plus fin. "],["structurer-un-script-r-de-manière-adéquate.html", "Chapitre 10 Structurer un script R de manière adéquate 10.1 En-tête du script 10.2 Nommer et commenter les sections 10.3 Documentation claire avec des commentaires 10.4 Script de contrôle avec run_all** 10.5 Gestion des scripts exploratoires 10.6 Conclusion", " Chapitre 10 Structurer un script R de manière adéquate La structure d’un script R joue un rôle clé dans la lisibilité, la maintenabilité et la reproductibilité de vos analyses. Un script bien organisé facilite la navigation, la compréhension des différentes étapes du workflow et la collaboration avec d’autres personnes. Voici quelques bonnes pratiques pour organiser vos scripts en sections claires et concises. 10.1 En-tête du script L’en-tête d’un script R est essentiel pour la documentation, la maintenance et le partage du code. Un en-tête bien rédigé permet aux utilisateurs de comprendre rapidement le contenu et l’objectif du script. Voici ses principaux avantages : Clarté : Un en-tête clair aide à saisir rapidement le rôle du script, même longtemps après son écriture. Documentation des intrants et sortants : En listant les fichiers d’entrée et de sortie, vous facilitez l’identification des dépendances et des données nécessaires pour l’exécution. Facilitation de la collaboration : Un en-tête informatif rend le script plus accessible pour les collègues, ce qui favorise le partage de connaissances. Amélioration de la reproductibilité : En indiquant les intrants et sortants, vous aidez les autres à reproduire les résultats avec les fichiers appropriés 10.1.1 Exemple d’en-tête # --------------------------------------------------------------------------- # Nom du Script : 03_analyse_avancee.R # Description : Ce script effectue une analyse exploratoire approfondie, # y compris des statistiques descriptives, des tests # statistiques et des visualisations pour les données # nettoyées. # # Intrants : - data/clean_data.csv # - scripts/fonctions_statistiques.R (fonctions personnalisées) # # Sortants : - output/statistiques_descriptives.csv (résultats des statistiques) # - output/visualisation_test.png (graphique des résultats) # # Auteur : VotreNom # Date : 2024-09-20 # # Notes : Ce script nécessite que le package &#39;ggplot2&#39; et &#39;dplyr&#39; soient # installés. Les résultats de l&#39;analyse seront sauvegardés dans # le dossier output. # --------------------------------------------------------------------------- 10.2 Nommer et commenter les sections Il est important de nommer chaque section de manière explicite pour indiquer clairement son but. Utilisez des titres comme “Chargement des packages”, “Importation des données”, “Nettoyage des données”, etc. Cela permet de naviguer rapidement dans le script et d’identifier la logique du flux de travail. 10.2.1 Bonnes pratiques pour les sections : Utilisez des titres explicites : Assurez-vous que chaque section décrit son contenu de manière concise et descriptive. Structure hiérarchique : Commencez toujours par les sections essentielles (chargement des packages, importation des données), puis avancez progressivement dans le pipeline de l’analyse (nettoyage, analyse, visualisation). # --------------------------------------------------------------------------- # 1. Chargement des packages et des fonctions # --------------------------------------------------------------------------- library(dplyr) library(ggplot2) source(&quot;scripts/fonctions_utiles.R&quot;) # --------------------------------------------------------------------------- # 2. Importation des données # --------------------------------------------------------------------------- data &lt;- read.csv(&quot;data/donnees_brutes.csv&quot;) # --------------------------------------------------------------------------- # 3. Nettoyage des données # --------------------------------------------------------------------------- # Suppression des valeurs manquantes et formatage des noms de colonnes data_clean &lt;- data %&gt;% drop_na() %&gt;% janitor::clean_names() # --------------------------------------------------------------------------- # 4. Analyse exploratoire # --------------------------------------------------------------------------- # Calcul des statistiques descriptives summary_stats &lt;- data_clean %&gt;% summarise(mean_value = mean(variable_x), sd_value = sd(variable_x)) # --------------------------------------------------------------------------- # 5. Visualisation des résultats # --------------------------------------------------------------------------- ggplot(data_clean, aes(x = variable_x, y = variable_y)) + geom_point() + labs(title = &quot;Relation entre X et Y&quot;) # --------------------------------------------------------------------------- # 6. Sauvegarde des résultats # --------------------------------------------------------------------------- write.csv(summary_stats, &quot;output/summary_stats.csv&quot;, row.names = FALSE) 10.2.2 Raccourcis clavier Pour insérer un commentaire de section : Windows : Ctrl + Shift + R Ce raccourci insère un commentaire de section préformaté, que vous pouvez ensuite personnaliser avec le nom de la section souhaitée. Pour naviguer entre les sections : Utilisez le volet “Plan” (ou “Outline”) dans RStudio pour voir toutes les sections de votre script. Cela vous permet de cliquer rapidement sur une section pour y accéder. Pour exécuter une section : Windows : Ctrl + Alt + T Ce raccourci exécute toutes les lignes de code dans la section en cours. 10.2.3 Avantages des sections Meilleure lisibilité : Les sections clairement délimitées rendent le code plus lisible. Navigation rapide : Le volet “Plan” vous permet de naviguer facilement dans le script sans faire défiler tout le code. Organisation logique : Les sections aident à structurer le script en étapes logiques, ce qui facilite la compréhension du flux de travail. 10.3 Documentation claire avec des commentaires Ajouter des commentaires au sein de chaque section est une pratique essentielle pour expliquer le rôle de chaque bloc de code. Les commentaires permettent de : Décrire ce que fait chaque section ou fonction. Expliquer les choix de certaines opérations complexes. Rendre votre script compréhensible pour vous-même à long terme, ou pour d’autres utilisateurs. 10.3.1 Exemple de commentaires : # Calcul de la moyenne et de l&#39;écart type pour la variable &#39;variable_x&#39; summary_stats &lt;- data_clean %&gt;% summarise(mean_value = mean(variable_x), # Moyenne sd_value = sd(variable_x)) # Écart type 10.4 Script de contrôle avec run_all** Si votre projet comporte plusieurs scripts qui doivent être exécutés dans un certain ordre, vous pouvez utiliser un script de contrôle appelé run_all qui exécute les autres scripts dans le bon ordre. Ce script centralise l’exécution de tout votre pipeline et assure la reproductibilité complète. # run_all.R : Script de contrôle pour exécuter toutes les étapes du projet source(&quot;scripts/01_importation.R&quot;) source(&quot;scripts/02_nettoyage.R&quot;) source(&quot;scripts/03_analyse.R&quot;) source(&quot;scripts/04_visualisation.R&quot;) Cela permet de relancer facilement tout le processus de bout en bout. 10.5 Gestion des scripts exploratoires Lorsque vous débutez un script, surtout dans un contexte exploratoire, il est fréquent de ne pas savoir exactement ce qu’il contiendra. L’exploration des données implique souvent des essais et des erreurs, et il est essentiel de garder une trace de votre réflexion et de vos découvertes. Voici quelques conseils pour structurer vos scripts exploratoires tout en restant en accord avec les bonnes pratiques. 10.5.1 Utiliser des commentaires pour documenter votre réflexion Ajoutez des commentaires tout au long du script pour expliquer vos pensées, les raisons de vos choix, et les résultats de vos explorations. Cela vous aidera à comprendre votre logique lorsque vous reviendrez sur le script plus tard. # Exploration des données : Vérification de la distribution des valeurs hist(data$variable_x) # Ici, je m&#39;interroge sur la présence d&#39;une asymétrie. Il serait intéressant de faire un test de normalité. 10.5.2 Inclure des sections même dans les scripts exploratoires Utilisez des sections pour structurer vos idées, même si le contenu n’est pas encore finalisé. Cela vous aidera à garder une organisation, même dans un contexte d’exploration. # --------------------------------------------------------------------------- # 1. Chargement des données # --------------------------------------------------------------------------- data &lt;- read.csv(&quot;data/exemple.csv&quot;) # --------------------------------------------------------------------------- # 2. Exploration initiale # --------------------------------------------------------------------------- summary(data) # Résumé des données str(data) # Structure des données 10.5.3 Écrire des notes et des questions Incluez des sections où vous notez vos questions, hypothèses, et réflexions sur les données. Cela peut servir de guide pour les étapes futures de votre analyse. # --------------------------------------------------------------------------- # 3. Réflexions # --------------------------------------------------------------------------- # Questions : # - Pourquoi y a-t-il tant de valeurs manquantes dans variable_y ? # - Quelle transformation pourrait être utile pour variable_x ? 10.5.4 Sauvegarder des versions du script Si vous travaillez sur une exploration qui évolue au fil du temps, envisagez de sauvegarder différentes versions de votre script. Cela vous permettra de revenir en arrière si nécessaire et de suivre l’évolution de votre réflexion. Si vous ne le faites pas déjà, envisagez d’utiliser Git pour gérer vos scripts exploratoires. Cela vous permettra de suivre les modifications apportées au fur et à mesure de votre exploration et de revenir à des versions antérieures si besoin. 10.6 Conclusion Une bonne organisation des scripts, même dans un contexte exploratoire, est essentielle pour garantir la lisibilité, la maintenabilité et la reproductibilité de vos projets. En gardant une trace de vos réflexions, questions, et résultats intermédiaires à travers des commentaires, des sections claires, et en utilisant des pratiques de gestion de version, vous pouvez transformer vos scripts exploratoires en documents utiles qui guideront vos analyses futures. Suivre ces bonnes pratiques vous permettra de revenir facilement sur vos scripts, de mieux comprendre vos processus à long terme, et de partager votre travail avec d’autres collaborateurs sans difficulté, même lors des étapes plus formelles du projet. "],["annexe-exemples-reprex.html", "Chapitre 11 Annexe : Exemples REPREX 11.1 Exemple 1 : Diagramme à bandes exactement comme design.ca 11.2 Exemple 2 : Diagramme à bandes pour rapport gouvernemental", " Chapitre 11 Annexe : Exemples REPREX 11.1 Exemple 1 : Diagramme à bandes exactement comme design.ca Voici un exemple de REPREX qui montre comment structurer un graphique en barres en suivant les bonnes pratiques de présentation. # REPREX - Graphique des parts de marché des navigateurs avec ggplot2 et grid # Ce script explique en détail comment construire un graphique avec des normes spécifiques de présentation. # Importer les librairies nécessaires -------------------------------------------------------- # ggplot2 : pour créer des graphiques basés sur les principes de la &quot;Grammaire des graphiques&quot;. # grid et gridExtra : pour manipuler l&#39;arrangement des éléments graphiques et ajouter des marges externes. # showtext et sysfonts : pour utiliser des polices personnalisées (Google Fonts) dans les graphiques. library(ggplot2) # Création de graphiques library(grid) # Manipulation d&#39;éléments graphiques (grille, texte) library(gridExtra) # Arranger plusieurs éléments graphiques dans une grille library(showtext) # Utilisation de polices Google Fonts library(sysfonts) # Charger des polices supplémentaires # Charger la police Google Open Sans --------------------------------------------------------- # Nous utilisons ici la police &quot;Open Sans&quot; de Google Fonts pour le texte. # Cette police est populaire et adaptée aux graphiques formels. font_add_google(&quot;Open Sans&quot;, &quot;open-sans&quot;) showtext_auto() # Activer showtext pour que la police soit appliquée aux graphiques # Fonction de conversion pixels -&gt; points ---------------------------------------------------- # Cette fonction est utilisée pour convertir des pixels en points, car certaines marges sont exprimées en points. # Dans R, 1 point correspond à 0,75 pixel. px_to_pt &lt;- function(px) { # Conversion de pixels en points (1 point = 0.75 pixel) return(px / 0.75) } # Créer des données fictives --------------------------------------------------------------- # Nous créons ici un jeu de données factice qui montre la part de marché de différents navigateurs web. # Les données sont organisées dans un tableau de données (data frame), et l&#39;axe des X est ordonné pour correspondre aux navigateurs. data &lt;- data.frame( navigateur = factor(c(&quot;Chrome&quot;, &quot;Safari&quot;, &quot;Edge&quot;, &quot;Firefox&quot;, &quot;Opera&quot;), levels = c(&quot;Chrome&quot;, &quot;Safari&quot;, &quot;Edge&quot;, &quot;Firefox&quot;, &quot;Opera&quot;)), # Ordre spécifique pour l&#39;axe X part_marche = c(65, 15, 5, 7, 3) # Parts de marché respectives ) # Créer le graphique avec ggplot2 --------------------------------------------------------- # Nous utilisons ggplot2 pour créer un graphique en barres. Chaque navigateur est représenté par une barre dont la hauteur reflète sa part de marché. p &lt;- ggplot(data, aes(x = navigateur, y = part_marche)) + geom_bar(stat = &quot;identity&quot;, fill = &quot;#095797&quot;, width = 0.67) + # Création des barres avec une couleur spécifique labs( title = &quot;Part de marché des navigateurs&quot;, # Titre du graphique x = NULL, # Retirer le titre de l&#39;axe X (pas nécessaire ici) y = NULL # Retirer le titre de l&#39;axe Y (pas nécessaire ici) ) + # Échelle de l&#39;axe Y avec des valeurs entre 0 et 100, sans espace en bas scale_y_continuous( expand = c(0, 0), # Retirer l&#39;espace en bas limits = c(0, 100), # Limite de 0 à 100 pour correspondre à des pourcentages breaks = c(0, 20, 40, 60, 80) # Position des repères sur l&#39;axe Y ) + # Thème du graphique theme_void() + # Commence avec un thème vide pour tout personnaliser theme( # Définition des marges autour du graphique (exprimées en points après conversion) plot.margin = margin(t = px_to_pt(0), r = px_to_pt(40), b = px_to_pt(0), l = px_to_pt(40), unit = &quot;pt&quot;), # Fond et bordures du graphique plot.background = element_rect(fill = NA, colour = &quot;#c5cad2&quot;, linewidth = 1), # Bordure grise autour du graphique panel.spacing.y = unit(px_to_pt(48), &quot;pt&quot;), # Espace entre le contenu du graphique et la bordure # Fond du panneau contenant le graphique panel.background = element_rect(fill = &quot;#FFFFFF&quot;, colour = &quot;#FFFFFF&quot;), # Fond blanc du panneau panel.grid.major.y = element_line(linewidth = 0.5, colour = &quot;#C5CAD2&quot;), # Ligne de grille pour l&#39;axe Y # Axe des X axis.line.x = element_line(linewidth = 1, colour = &quot;#6B778A&quot;), # Ligne de l&#39;axe des X avec une couleur spécifique axis.text.x = element_text( family = &quot;open-sans&quot;, size = 12, color = &quot;#6b778a&quot;, # Style des étiquettes des navigateurs margin = margin(t = px_to_pt(8), b = px_to_pt(48), unit = &quot;pt&quot;), # Marges autour des étiquettes hjust = 0.5 # Centrer les étiquettes sous chaque barre ), # Titre du graphique plot.title = element_text( family = &quot;open-sans&quot;, face = &quot;bold&quot;, size = 16, color = &quot;#223654&quot;, # Style du titre margin = margin(t = px_to_pt(48), unit = &quot;pt&quot;) # Espace au-dessus du titre ) ) + # Ajout de textes supplémentaires pour l&#39;axe Y (positions fixes) annotate(&quot;text&quot;, x = 0, y = 80, label = &quot;80 % d&#39;utilisation par navigateur&quot;, hjust = 0, vjust = -0.5, size = 4, family = &quot;open-sans&quot;, color = &quot;#6b778a&quot;) + annotate(&quot;text&quot;, x = 0, y = 60, label = &quot;60&quot;, hjust = 0, vjust = -0.5, size = 4, family = &quot;open-sans&quot;, color = &quot;#6b778a&quot;) + annotate(&quot;text&quot;, x = 0, y = 40, label = &quot;40&quot;, hjust = 0, vjust = -0.5, size = 4, family = &quot;open-sans&quot;, color = &quot;#6b778a&quot;) + annotate(&quot;text&quot;, x = 0, y = 20, label = &quot;20&quot;, hjust = 0, vjust = -0.5, size = 4, family = &quot;open-sans&quot;, color = &quot;#6b778a&quot;) + annotate(&quot;text&quot;, x = 0, y = 0, label = &quot;0&quot;, hjust = 0, vjust = -0.5, size = 4, family = &quot;open-sans&quot;, color = &quot;#6b778a&quot;) # Utilisation de grid pour ajuster les marges externes autour du graphique ---------------- # Ici, nous ajoutons une marge externe au graphique pour créer un espace supplémentaire en haut et en bas. # Cela est utile pour contrôler l&#39;espacement dans des documents ou des présentations. grid.newpage() # Crée une nouvelle page graphique avant de dessiner le graphique avec des marges supplémentaires # Ajouter des marges externes autour du graphique ---------------------------------------- grid.draw(gridExtra::grid.arrange( p, # Le graphique ggplot que nous avons créé top = textGrob(&quot; &quot;, gp = gpar(fontsize = px_to_pt(72))), # Marge en haut de 72 pixels convertis en points bottom = textGrob(&quot; &quot;, gp = gpar(fontsize = px_to_pt(72))) # Marge en bas de 72 pixels convertis en points )) 11.2 Exemple 2 : Diagramme à bandes pour rapport gouvernemental # Importer les bibliothèques nécessaires library(ggplot2) # Pour créer des graphiques avec ggplot2 library(grid) # Pour manipuler des éléments graphiques (comme les marges, les lignes) library(showtext) # Pour utiliser des polices Google Fonts dans les graphiques library(sysfonts) # Pour charger des polices supplémentaires # Charger la police Google Open Sans --------------------------------------------------------- # Ici, nous utilisons la police &quot;Open Sans&quot; de Google Fonts, qui est bien adaptée pour un rendu clair # et propre dans les graphiques formels. font_add_google(&quot;Open Sans&quot;, &quot;open-sans&quot;) showtext_auto() # Activer showtext pour que la police soit correctement rendue dans les graphiques # Fonction utilitaire pour convertir des pixels en points ------------------------------------ # Cette fonction convertit des pixels en points, car ggplot fonctionne souvent avec des unités # en points. (1 point = 0.75 pixel). px_to_pt &lt;- function(px) { return(px / 0.75) } # Création d&#39;un jeu de données simulé -------------------------------------------------------- # Ce jeu de données est utilisé pour reproduire la figure avec des mesures de carbone organique # par station. set.seed(123) # Fixer une graine pour garantir la reproductibilité des résultats # Définir les noms des stations stations &lt;- c(&quot;Bree02A&quot;, &quot;Bree02B&quot;, &quot;Bree03&quot;, &quot;Bree04&quot;, &quot;Bree05&quot;, &quot;Tru01&quot;, &quot;Tru02&quot;, &quot;Tru03&quot;, &quot;Tru04&quot;, &quot;Tru05&quot;) # Définir les valeurs de carbone organique total (%) carbone_organique &lt;- c(2, 6, 1.5, 4, 12, 3, 2.5, 4.5, 5, 4) # Ajouter des barres d&#39;erreur simulées (écart-type) pour chaque mesure erreur &lt;- c(0.5, 1.5, 0.2, 0.8, 3.0, 0.8, 0.6, 1.2, 1.0, 0.8) # Localisation des stations (lac Bree ou lac Truite) localisation &lt;- rep(c(&quot;Bree&quot;, &quot;Tru&quot;), each = 5) # Création du data.frame avec les colonnes nécessaires data &lt;- data.frame(Station = stations, Carbone_organique = carbone_organique, Erreur = erreur, Lac = localisation) # Afficher les premières lignes du jeu de données pour vérifier sa structure head(data) # Création du thème personnalisé pour le graphique ------------------------------------------ # Nous créons un thème personnalisé pour harmoniser les éléments graphiques du diagramme. custom_theme &lt;- theme_void() + # Commence par un thème vide sans éléments par défaut theme( # Marges autour du graphique (haut, droite, bas, gauche) en points plot.margin = margin(t = px_to_pt(48), r = px_to_pt(40), b = px_to_pt(48), l = px_to_pt(40), unit = &quot;pt&quot;), # Définir un fond blanc avec une bordure grise autour du graphique plot.background = element_rect(fill = &quot;#FFFFFF&quot;, colour = &quot;#c5cad2&quot;, linewidth = 1), # Fond blanc pour le panneau du graphique panel.background = element_rect(fill = &quot;#FFFFFF&quot;, colour = &quot;#FFFFFF&quot;), # Grille pour l&#39;axe Y en ligne fine grise panel.grid.major.y = element_line(linewidth = 0.5, colour = &quot;#C5CAD2&quot;), # Ligne de l&#39;axe X avec une couleur grise axis.line.x = element_line(linewidth = 1, colour = &quot;#6B778A&quot;), # Position de la légende en bas du graphique legend.position = &quot;bottom&quot;, # Style des étiquettes de l&#39;axe des X axis.text.x = element_text( family = &quot;open-sans&quot;, size = 14, color = &quot;#6b778a&quot;, # Police Open Sans, couleur grise margin = margin(t = px_to_pt(8), b = px_to_pt(16), unit = &quot;pt&quot;), # Marges autour des étiquettes hjust = 0.5 # Centrer les étiquettes sous chaque barre ), # Style des étiquettes de l&#39;axe des Y axis.text.y = element_text( family = &quot;open-sans&quot;, size = 14, color = &quot;#6b778a&quot;, # Police Open Sans, couleur grise margin = margin(r = px_to_pt(8), l = px_to_pt(16), unit = &quot;pt&quot;), # Marges autour des étiquettes hjust = 0.5 # Centrer les étiquettes de l&#39;axe Y ), # Style du titre de l&#39;axe des X axis.title.x = element_text( family = &quot;open-sans&quot;, size = 14, color = &quot;#6b778a&quot;, # Police Open Sans margin = margin(b = px_to_pt(32), unit = &quot;pt&quot;), # Marges sous le titre hjust = 0.5 # Centrer le titre ), # Style du titre de l&#39;axe des Y axis.title.y = element_text( family = &quot;open-sans&quot;, size = 14, color = &quot;#6b778a&quot;, angle = 90, # Angle de 90° pour le titre de l&#39;axe Y hjust = 0.5 # Centrer verticalement ), # Style de la légende (sans titre et police Open Sans) legend.title = element_blank(), legend.text = element_text(family = &quot;open-sans&quot;, size = 14, color = &quot;#6b778a&quot;), legend.key.size = unit(px_to_pt(16), &quot;pt&quot;) # Taille des éléments de la légende ) # Générer le graphique avec ggplot2 --------------------------------------------------------- ggplot(data, aes(x = Station, y = Carbone_organique, fill = Lac)) + # Variable x: Station, y: Carbone organique geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, width = 0.67) + # Barres pour chaque station geom_errorbar(aes(ymin = Carbone_organique - Erreur, ymax = Carbone_organique + Erreur), width = 0.2, color = &quot;#223654&quot;) + # Ajout des barres d&#39;erreur labs(x = &quot;Station&quot;, y = &quot;Carbone organique total (%)&quot;) + # Labels pour les axes scale_y_continuous( limits = c(0, 21), # Limiter l&#39;axe des Y de 0 à 21 breaks = c(0, 5, 10, 15, 20), # Intervalles des graduations de l&#39;axe Y expand = c(0, 0) # Retirer l&#39;espace vide en bas de l&#39;axe ) + scale_x_discrete(labels = gsub(&quot;(Bree|Tru)&quot;, &quot;&quot;, stations)) + # Enlever &quot;Bree&quot; et &quot;Tru&quot; des étiquettes de l&#39;axe X scale_fill_manual( values = c(&quot;Bree&quot; = &quot;#D56050&quot;, &quot;Tru&quot; = &quot;#68CEBA&quot;), # Définir les couleurs pour les lacs Bree et Tru labels = c(&quot;Bree&quot; = &quot;Lac Breeches&quot;, &quot;Tru&quot; = &quot;Lac Truite&quot;) # Modifier les labels de la légende ) + custom_theme # Appliquer le thème personnalisé 11.2.1 Exporter un graphique depuis le volet Plots dans RStudio Pour exporter un graphique affiché dans le volet Plots de RStudio, suivez ces étapes : Créer votre graphique : Exécutez votre code pour afficher le graphique dans le volet Plots. Exporter le graphique : Sauvegarder comme image : Cliquez sur le bouton Export en haut à droite du volet Plots. Sélectionnez Save As Image. Choisissez le format (PNG, JPEG, etc.), le nom de fichier, la résolution (DPI), et l’emplacement de sauvegarde. Cliquez sur Save pour enregistrer l’image. Copier dans le presse-papier : Cliquez sur Export. Sélectionnez Copy to Clipboard. Collez ensuite le graphique directement dans un document (Word, PowerPoint, etc.) en utilisant la commande de collage (Ctrl + V). 11.2.2 Note Il n’existe pas de commande R pour reproduire exactement ces actions manuelles. Toutefois, vous pouvez utiliser la fonction ggsave() pour automatiser l’enregistrement d’un graphique dans un script, mais cela n’offre pas les options visuelles du volet Plots. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
